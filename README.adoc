# Comparing Distributed Programming in Rust and Go

## Overview

The purpose of this project is to compare the programming languages Rust and Go regarding their capabilities and characteristics for distributed programming.

## Serialization and Messaging

One thing that is pretty much inevitable when it comes to distributed systems programming is to have some form of messaging solution so that individual computing nodes can exchange serialized data.

A widely used solution for this is Google's gRPC so let's take a look at gRPC implementations for Go and Rust.

On https://www.crates.io[crates.io] you can find multiple crates (Rust's version of packages/libraries) that offer gRPC implementations. The most promising one at the time seems to be https://crates.io/crates/tonic[tonic] because it has the highest number of all-time and recent downloads.

The directory `examples/grpc/rust-grpc` contains a working example for a small gRPC service with a client and server built with tonic. What's nice about tonic is that it supports protobuf code generation. This means that you can supply your own protobuf source files and let tonic generate Rust code that contains `structs` that represent the protobuf messages and `traits` for implementing the gRPC service in your server and client.

In this example the file link:examples/grpc/rust-grpc/notes.proto[notes.proto] contains the protobuf definition for the noticeboard service.
To generate Rust code for implementing the service all we need to do is add a file called `build.rs` in the root directory with the following content:
[source,rust]
----
fn main() {
    tonic_build::compile_protos("proto/notes.proto")
        .unwrap_or_else(|e| panic!("Failed to compile protos {:?}", e));
}
----
Now we can run `cargo build` to compile our code.

For Go:
compile protobuf `protoc --proto_path=../proto --go_out=plugins=grpc:build/gen ../proto/notes.proto`

Some notes:

- generating the code from protobuf definitions is actually easier with rust and tonic because you only one command whereas with go you have to invoke protoc seperately

## Asynchronous Programming

## Available Frameworks  

When it comes to building large distributed systems that are suited for production use in an enterprise environment, most of the time you probably don't want to build everything from scratch. So it makes sense to choose a framework or platform to build upon. Ideally, this should be one that is already being used by many other people and has turned out to be tried and true.

### Frameworks for Go
|===
|Name |Description 

|test
|test
|TEst

|===

### Frameworks for Rust
|===
|Name |Description 

|test
|test
|TEst

|===

## Additional Thoughts

One central aspect of Rust's philosophy is its focus on performance.
Although better low-level performance is in general a good thing, this particular advantage of Rust might not be as useful when it comes to building distributed systems. Since the performance of a distributed system as a whole tends to be constrained more by network latency than by the execution time of individual tasks.

On the other hand, the fact that Rust offers very good memory efficiency means that it could be suited very well for distributed systems that keep a lot of data in memory at a time. For example, the authors of the Ballista framework claim that:

__"The combination of Rust and Arrow provides excellent memory efficiency and memory usage can be 5x - 10x lower than Apache Spark in some cases"__footnote:[https://github.com/ballista-compute/ballista#how-does-this-compare-to-apache-spark]

## Summary


WARNING: Remove this

### Asciidocschnipsel:
 - a
 - b
 - c

|===
|Name |Go |Rust

|test
|test
|TEst

|===